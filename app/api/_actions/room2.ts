'use server'
import { fetchUser } from './user';
import { generateRandomCode } from '@/app/_utils/codeGen';
import createClient from '@/supabase/clients/server';
import logger from '@/app/_utils/logger';
import { Tables, TablesInsert, Json } from "@/supabase/types/database.types";
import { TLStoreSnapshot } from "tldraw";
import { revalidatePath } from 'next/cache';
import { PostgrestError } from '@supabase/supabase-js';
import { cache } from 'react';


export type RoomInsert = TablesInsert<'rooms'>
export type Capsule = Tables<'capsules'>
// TODO: use the same Omit technique for the capsule object, and remove thge unneccessary Json[] array type in supabase

export interface RoomParams {
    navigation: {
        type: 'pratico' | 'animateur' | 'libre'
        follow: string
    },
    collaboration: {
        active: boolean
        allowAll: boolean
        allowedUsersIds: string[]
    }
}

/**
 * We use the type generated by supabase, but we replace the `Json`
 * columns with our types
 */
export type Room = Omit<Tables<'rooms'>, 'params' | 'capsule_snapshot'> & {
    params: RoomParams | null
    capsule_snapshot: TLStoreSnapshot | null
}


export const fetchCapsule = cache(async(capsuleId: string) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').select('*').eq('id', capsuleId).single()
    if (error) logger.error('supabase:database', 'Error fetching capsule', error.message)
    return { data, error: error?.message }
})


export const fetchCapsuleSnapshot = cache(async (capsuleId: string) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').select('tld_snapshot').eq('id', capsuleId).single()
    if (error) logger.error('supabase:database', 'Error fetching capsule snapshot', error.message)
    return { data, error: error?.message }
})


export const fetchCapsuleTitle = cache(async (capsuleId: string) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').select('title').eq('id', capsuleId).single()
    if (error) logger.error('supabase:database', 'Error fetching capsule title', error.message)
    return { data, error: error?.message }
})


export const saveCapsuleTitle = cache(async (capsuleId: string, title: string) => {
    let result: {error: string | null} = { error: null }

    if (title.length === 0) result = { error: 'Title cannot be empty' }
    if (title.length > 100) result = { error: 'Title cannot be longer than 100 characters' }
    if (title.length < 3)   result = { error: 'Title must be at least 3 characters long' }

    if (result.error) {
        logger.error('supabase:database', 'Error saving capsule title', result.error)
        return result
    }

    const supabase = createClient()
    const { error } = await supabase.from('capsules').update({ title }).eq('id', capsuleId)

    if (error) {
        logger.error('supabase:database', 'Error saving capsule title', error.message)
        return { error: error.message }
    } else {
        return { error: null }
    }
})


const saveSnapshotToCapsules = cache(async (capsuleId: string, snapshot: TLStoreSnapshot) => {
    const supabase = createClient()
    const jsonSnapshot = snapshot as unknown as Json
    const { data, error } = await supabase.from('capsules').update({ tld_snapshot: [jsonSnapshot] }).eq('id', capsuleId)
    if (error) logger.error('supabase:database', 'Error saving snapshot to capsule', error.message)
    return { data, error: error?.message }
})


const saveRoom = cache(async (room: RoomInsert) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').upsert(room).select()
    if (error) logger.error('supabase:database', 'Error saving room', error.message)
    return { data, error: error?.message }
})

//export async function deleteRoom(roomId: number) {
export const deleteRoom = cache(async (roomId: number) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').delete().eq('id', roomId)
    if (error) logger.error('supabase:database', 'Error deleting room', error.message)
    if (!error) revalidatePath('/', 'layout')
    return { data, error: error?.message }
})


export const fetchRoomsCodes = cache(async () => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('code')
    if (error) logger.error('supabase:database', 'Error fetching rooms codes', error.message)
    return { data, error: error?.message }
})


export const createRoom = cache(async (capsuleId: string) => {
    const { user, error: userError } = await fetchUser()
    if (userError) return { room: null, error: userError }
    if (!user) return { room: null, error: 'No user' }

    const { data, error } = await fetchCapsuleSnapshot(capsuleId)
    const snapshot = data?.tld_snapshot?.[0]
    if (error) return { room: null, error }
    if (!snapshot) return { room: null, error: 'No capsule snapshot to use for room' }

    let code = generateRandomCode()
    
    // Ensure the code is unique
    const { data: existingCodes, error: errorCodes } = await fetchRoomsCodes()
    if (existingCodes) {
        while (existingCodes.includes({ code })) {
            code = generateRandomCode()
        }
    }

    // generate room params
    const params: RoomParams = { 
        navigation: { type: 'animateur', follow: user.id},
        collaboration: { active: true, allowAll: false, allowedUsersIds: [] }
    }

    // Generate the room object
    const room: RoomInsert = { code: code, capsule_id: capsuleId, capsule_snapshot: snapshot, params: params as unknown as Json }

    // Set the room in the database, and get the room that is created
    const { data: createdRoomA, error: errorRoom } = await saveRoom(room)

    if (errorRoom) return { room: null, error: errorRoom }
    if (!createdRoomA) return { room: null, error: 'saveRomm returned no room' }

    // Not sure why this is an array, but we only want the first element
    const createdRoom = createdRoomA[0]

    // Revalidate cache
   //revalidatePath(`/room/${createdRoom.code}`)

    return { room: createdRoom, error: null }
})


//export async function saveCapsuleSnapshot(capsuleId: string, snapshot: any) {
export const saveCapsuleSnapshot = cache(async (capsuleId: string, snapshot: any) => {
    const { data, error } = await saveSnapshotToCapsules(capsuleId, snapshot)
    return { data, error }
})


export const saveRoomSnapshot = cache(async (roomId: number, snapshot: any) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').update({ capsule_snapshot: snapshot as unknown as Json }).eq('id', roomId)
    if (error) logger.error('supabase:database', 'Error saving room snapshot', error.message)
    return { data, error: error?.message }
})

/**
 * Get rooms related to a capsule
 */
export const fetchRoomsByCapsuleId = cache(async (capsuleId: string) => {
    const supabase = createClient()    
    const { data, error } = await supabase.from('rooms').select('*').eq('capsule_id', capsuleId)
    if (error) logger.error('supabase:database', 'Error fetching rooms by capsule id', error.message)
    return { data, error: error?.message }
})


export const fetchRoomParams = cache(async (roomId: number) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('params').eq('id', roomId).single()
    if (error) logger.error('supabase:database', 'Error fetchRoomParams', error.message)
    return { data, error: error?.message }
})


export const saveRoomParams = cache(async (roomId: number, params: RoomParams) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').update({ params: params as unknown as Json }).eq('id', roomId)
    if (error) logger.error('supabase:database', 'Error saveRoomParams', error.message)
    return { data, error: error?.message }
})




