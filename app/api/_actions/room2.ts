'use server'
import { fetchUser } from './user';
import { generateRandomCode } from '@/app/_utils/codeGen';
import createClient from '@/supabase/clients/server';
import logger from '@/app/_utils/logger';
import { Tables, TablesInsert, Json } from "@/supabase/types/database.types";
import { TLStoreSnapshot } from "tldraw";
import { revalidatePath } from 'next/cache';
import { PostgrestError } from '@supabase/supabase-js';


export type RoomInsert = TablesInsert<'rooms'>
export type Capsule = Tables<'capsules'>
// TODO: use the same Omit technique for the capsule object, and remove thge unneccessary Json[] array type in supabase

export interface RoomParams {
    navigation: {
        type: 'pratico' | 'animateur' | 'libre'
        follow: string
    },
    collaboration: {
        active: boolean
        allowAll: boolean
        allowedUsersIds: string[]
    }
}

/**
 * We use the type generated by supabase, but we replace the `Json`
 * columns with our types
 */
export type Room = Omit<Tables<'rooms'>, 'params' | 'capsule_snapshot'> & {
    params: RoomParams | null
    capsule_snapshot: TLStoreSnapshot | null
}


export async function fetchCapsule(capsuleId: string): Promise<Capsule> {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').select('*').eq('id', capsuleId).single()
    if (error) {
        throw error
    } else {
        logger.log('supabase:database', 'got capsule', (data as Capsule).title)
        return data
    }
}

export async function fetchCapsuleSnapshot(capsuleId: string): Promise<TLStoreSnapshot | undefined> {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').select('tld_snapshot').eq('id', capsuleId).single()
    if (error) {
        throw error
    } else {
        return data.tld_snapshot?.[0] as TLStoreSnapshot || undefined
    }
}

export async function fetchCapsuleTitle(capsuleId: string): Promise<string> {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').select('title').eq('id', capsuleId).single()
    if (error) {
        throw error
    } else {
        return data.title || ''
    }
}

export async function saveCapsuleTitle(capsuleId: string, title: string) {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').update({ title }).eq('id', capsuleId)
    if (error) {
        throw error as PostgrestError
    } else {
        return data
    }
}

export async function saveSnapshotToCapsules(capsuleId: string, snapshot: TLStoreSnapshot) {
    const supabase = createClient()
    const { data, error } = await supabase.from('capsules').update({ tld_snapshot: [snapshot] }).eq('id', capsuleId)
    if (error) {
        throw error
    } else {
        return data
    }
}

export async function saveRoom(room: TablesInsert<'rooms'>) {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').upsert(room).select()
    if (error) {
        throw error
    } else {
        return data[0] as Room // TODO: not sure about this
    }
}

export async function deleteRoom(roomId: number) {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').delete().eq('id', roomId)
    if (error) {
        throw error
    } else {
        // Revalidate cache
        revalidatePath('/', 'layout')
        return data
    }
}

export async function fetchRoomsCodes() {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('code')
    if (error) {
        throw error
    } else {
        const codesArray = data.map((e: { code: string }) => e.code)
        return codesArray
    }
}


export async function createRoom(capsuleId: string): Promise<Room> {
    if (!capsuleId) throw new Error('No capsule id provided for start button')

    const snapshot = await fetchCapsuleSnapshot(capsuleId)
    let code = generateRandomCode()
    
    // Ensure the code is unique
    const existingCodes = await fetchRoomsCodes()
    while (existingCodes.includes(code)) {
        code = generateRandomCode()
    }

    // generate room params
    const userId = (await fetchUser()).id
    const params: RoomParams = { 
        navigation: { type: 'animateur', follow: userId },
        collaboration: { active: true, allowAll: false, allowedUsersIds: [] }
    }

    // Generate the room object
    const room: RoomInsert = { code: code, capsule_id: capsuleId, capsule_snapshot: snapshot as unknown as Json, params: params as unknown as Json }

    try {
        // Set the room in the database, and get the room that is created
        const createdRoom = await saveRoom(room)

        // Revalidate cache
        revalidatePath('/', 'layout')

        return createdRoom // We'll need this to set the room in the context
    } catch (error) {
        throw error
    }
}


export async function saveCapsuleSnapshot(capsuleId: string, snapshot: any) {
    try {
        await saveSnapshotToCapsules(capsuleId, snapshot)
    } catch (error) {
        throw error
    }
}

export async function saveRoomSnapshot(roomId: number, snapshot: any) {
    const supabase = createClient()
    const { error } = await supabase.from('rooms').update({ capsule_snapshot: snapshot as unknown as Json }).eq('id', roomId)
    if (error) {
        logger.log('supabase:database', 'Error saving room snapshot', error.message)
        throw error
    } else {
        logger.log('supabase:database', 'Saved room snapshot to', roomId)
    }
}

/**
 * Get rooms related to a capsule
 */
export async function fetchRoomsByCapsuleId(capsuleId: string): Promise<Room[]> {
    const supabase = createClient()

    try {
        const { data, error } = await supabase.from('rooms').select('*').eq('capsule_id', capsuleId)
        if (error) {
            throw error
        } else {
            const result = data as Room[]
            logger.log('supabase:database', 'fetchRoomsByCapsuleId', capsuleId)
            return result
        }
    } catch (error) {
        logger.error('supabase:database', 'Error fetchRoomsByCapsuleId', (error as Error).message)
        throw error
    }
}


export async function fetchRoomParams(roomId: number): Promise<RoomParams> {
    const supabase = createClient()
    logger.log('supabase:database', 'fetching room params for', roomId, '...')
    const { data, error } = await supabase.from('rooms').select('params').eq('id', roomId).single()
    if (error) {
        logger.error('supabase:database', 'Error fetchRoomParams', error.message)
        throw error
    } else {
        logger.log('supabase:database', 'fetched room params for', roomId, data.params)
        return data.params as RoomParams
    }
}


export async function saveRoomParams(roomId: number, params: RoomParams) {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').update({ params: params as unknown as Json }).eq('id', roomId)
    if (error) {
        logger.error('supabase:database', 'Error saveRoomParams', error.message)
        throw error
    } else {
        logger.log('supabase:database', 'Saved room params for', roomId)
        return data
    }
}




