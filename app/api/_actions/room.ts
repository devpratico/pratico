'use server'
import { sanitizeUuid } from './../../_utils/utils_functions';
import createClient from "@/supabase/clients/server"
import logger from "@/app/_utils/logger"
import { cache } from "react"
import { fetchUser } from "./user"
import { TablesInsert, Tables, Json } from "@/supabase/types/database.types"
import { TLStoreSnapshot } from "tldraw"
import { revalidatePath } from "next/cache"
import { generateRandomCode } from "@/app/_utils/codeGen"
import { fetchCapsuleSnapshot } from "./capsule"

export type RoomInsert = TablesInsert<'rooms'>
export type Capsule = Tables<'capsules'>
// TODO: use the same Omit technique for the capsule object, and remove thge unneccessary Json[] array type in supabase

export interface RoomParams {
    navigation: {
        type: 'pratico' | 'animateur' | 'libre'
        follow: string
    },
    collaboration: {
        active: boolean
        allowAll: boolean
        allowedUsersIds: string[]
    }
}

export interface BaseActivitySnapshot {
    activityId: number;
    currentQuestionIndex: number;
    currentQuestionState: 'answering' | 'results';
}

export interface QuizSnapshot extends BaseActivitySnapshot {
    // TODO: Add the users answers
}

export interface PollSnapshot extends BaseActivitySnapshot {
    /**
     * Number of votes for each answer, in the same order as the answers in the question
     */
    votes: number[]
}

export type ActivitySnapshot = QuizSnapshot | PollSnapshot

/**
 * We use the type generated by supabase, but we replace the `Json`
 * columns with our types
 */
export type Room = Omit<Tables<'rooms'>, 'params' | 'capsule_snapshot' | 'activity_snapshot'> & {
    params: RoomParams | null
    capsule_snapshot: TLStoreSnapshot | null
    activity_snapshot: ActivitySnapshot | null
}


export const stopRoom = async (roomId: number) => {
    const supabase = createClient()

    const { error } = await supabase.from('rooms').update({ status: 'closed' }).eq('id', roomId)
    if (error) {
        logger.error('supabase:database', 'Error stopping room', error)
        return { error: error.message }
    }

    return { error: null }
}


export const getRoomId = cache(async (roomCode: string) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('id').eq('code', roomCode).single()
    if (error) logger.error('supabase:database', 'Error getting room id', error)
    return { id: data?.id, error: error?.message }
})


interface toggleCollaborationForArgs {
    userId: string
    roomCode: string
}


export const toggleCollaborationFor = async ({ userId, roomCode }: toggleCollaborationForArgs) => {
    const { id: roomId } = await getRoomId(roomCode.toString())
    if (!roomId) {
        logger.error('supabase:database', `No roomId - can't toggle collaboration for user`)
        return
    }
    const {data, error} = await fetchRoomParams(roomId)
    if (error) {
        logger.error('supabase:database', 'Error fetching room params', error)
        return
    }

    let params = data?.params as any

    if (!params || !params?.collaboration) {
        logger.error('supabase:database', `No params object found - can't toggle collaboration for user`)
        return
    }

    params.collaboration.allowAll = false // reset allowAll - we are now in 'manual' mode

    if (params.collaboration.allowedUsersIds.includes(userId)) {
        logger.log('supabase:database', 'removing user from allowed collab users', userId)
        params.collaboration.allowedUsersIds = params.collaboration.allowedUsersIds.filter((e: string) => e !== userId)

    } else {
        logger.log('supabase:database', 'adding user to allowed collab users', userId)
        params.collaboration.allowedUsersIds.push(userId)
    }

    const { data: saveData, error: saveError } = await saveRoomParams(roomId, params)

    
}


interface toggleCollaborationForAllArgs {
    roomCode: string
    /**
     * We need all users in order to allow them all when needed
     * (Not 100% satisfied with this)
     */
    allUsersIds: string[]
}


export const toggleCollaborationForAll = async ({ roomCode, allUsersIds }: toggleCollaborationForAllArgs) => {
    //const roomId = await getRoomId(roomCode.toString())
    const { id: roomId } = await getRoomId(roomCode.toString())
    if (!roomId) {
        logger.error('supabase:database', `No roomId - can't toggle collaboration for all`)
        return { data: null, error: 'No roomId' }
    }

    const {data, error } = await fetchRoomParams(roomId)

    if (error) {
        logger.error('supabase:database', 'Error fetching room params', error)
        return { data: null, error: error }
    }

    let params = data?.params as any

    params.collaboration.allowAll = !params.collaboration.allowAll

    // if we are disabling allowAll, we need to reset the allowed users
    if (!params.collaboration.allowAll) {
        params.collaboration.allowedUsersIds = []
    } else {
        // if we are enabling allowAll, we need to add all users to the allowed users.
        params.collaboration.allowedUsersIds = allUsersIds
    }


    return await saveRoomParams(roomId, params)
}


const saveRoom = async (room: RoomInsert) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').upsert(room).select()
    if (error) logger.error('supabase:database', 'Error saving room', error.message)
    return { data, error: error?.message }
}


export const deleteRoom = async (roomId: number) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').delete().eq('id', roomId)
    if (error) logger.error('supabase:database', 'Error deleting room', error.message)
    if (!error) revalidatePath('/')
    return { data, error: error?.message }
}


export const fetchRoomsbyUser = cache(async (userId: string) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('id, created_at').eq('created_by', userId)
    if (error) logger.error('supabase:database', 'Error fetching rooms codes', error.message)
    return { data, error: error?.message }
})


export const fetchClosedRoomsCodes = cache(async () => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('code').eq('status', 'closed')
    if (error) logger.error('supabase:database', 'Error fetching rooms codes', error.message)
    return { data, error: error?.message }
})

export const fetchOpenRoomsCodes = cache(async () => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('code').eq('status', 'open')
    if (error) logger.error('supabase:database', 'Error fetching rooms codes', error.message)
    return { data, error: error?.message }
})


export const createRoom = async (capsuleId: string) => {
    const { user, error: userError } = await fetchUser()
    if (userError) return { room: null, error: userError }
    if (!user) return { room: null, error: 'No user' }

    const { data, error } = await fetchCapsuleSnapshot(capsuleId)
    const snapshot = data?.tld_snapshot?.[0]
    if (error) return { room: null, error }
    if (!snapshot) return { room: null, error: 'No capsule snapshot to use for room' }

    let code = generateRandomCode()

    // Ensure the code is unique
    const { data: existingCodes, error: errorCodes } = await fetchOpenRoomsCodes()
    if (existingCodes) {
        while (existingCodes.includes({ code })) {
            code = generateRandomCode()
        }
    }

    // generate room params
    const params: RoomParams = {
        navigation: { type: 'animateur', follow: user.id },
        collaboration: { active: true, allowAll: false, allowedUsersIds: [] }
    }

    // Generate the room object
    const room: RoomInsert = {
        code: code,
        capsule_id: capsuleId,
        capsule_snapshot: snapshot,
        params: params as unknown as Json,
        status: 'open',
    }

    // Set the room in the database, and get the room that is created
    const { data: createdRoomA, error: errorRoom } = await saveRoom(room)

    if (errorRoom) return { room: null, error: errorRoom }
    if (!createdRoomA) return { room: null, error: 'saveRomm returned no room' }

    // Not sure why this is an array, but we only want the first element
    const createdRoom = createdRoomA[0]

    // Revalidate cache
    //revalidatePath(`/room/${createdRoom.code}`)

    return { room: createdRoom, error: null }
}


export const saveRoomSnapshot = async (roomId: number, snapshot: any) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').update({ capsule_snapshot: snapshot as unknown as Json }).eq('id', roomId)
    if (error) logger.error('supabase:database', 'Error saving room snapshot', error.message)
    return { data, error: error?.message }
}

export const fetchRoomDate = cache(async (roomId: number) => {
	if (!roomId)
		return ({data: null, error: 'fetchRoom: roomId missing'})
	logger.debug("next:api", "fetchRoomsByroomId", roomId, "sanitized: ", roomId);
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('created_at').eq('id', roomId).single();
    if (error) logger.error('supabase:database', 'Error fetching rooms by room id', error.message)
    return { data, error: error?.message }
})

export const fetchRoomsByCapsuleId = cache(async (capsuleId: string) => {
	const sanitizedCapsuleId = sanitizeUuid(capsuleId);
	if (!sanitizedCapsuleId)
		return ({data: null, error: 'fetchRoomsByCapsuleId: capsuleId missing'})
	logger.debug("next:api", "fetchRoomsByCapsuleId", capsuleId, "sanitized: ", sanitizedCapsuleId);
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('*').eq('capsule_id', sanitizedCapsuleId)
    if (error) logger.error('supabase:database', 'Error fetching rooms by capsule id', error.message)
    return { data, error: error?.message }
})


export const fetchRoomParams = cache(async (roomId: number) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('params').eq('id', roomId).single()
    if (error) logger.error('supabase:database', 'Error fetchRoomParams', error.message)
    return { data, error: error?.message }
})


export const saveRoomParams = async (roomId: number, params: RoomParams) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').update({ params: params as unknown as Json }).eq('id', roomId)
    if (error) logger.error('supabase:database', 'Error saveRoomParams', error.message)
    return { data, error: error?.message }
}


export const fetchOpenRoomByCode = async (code: string) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('*').eq('code', code).eq('status', 'open').single()

    if (error) logger.error('supabase:database', `error getting room by code "${code}"`, error.message)

    return { data, error: error?.message }
}


export const fetchRoomCreator = async (code: string) => {
    const supabase = createClient()
    const { data, error } = await supabase.from('rooms').select('created_by').eq('code', code).single()

    if (error) logger.error('supabase:database', 'fetchRoomCreator', `error getting room creator by code "${code}"`, error.message)

    return { data, error: error?.message }
}


export const saveRoomActivitySnapshot = async (roomId: number, snapshot: ActivitySnapshot | null) => {
    const supabase = createClient()

    const { data, error } = await supabase.from('rooms').update({
        activity_snapshot: snapshot ? snapshot as unknown as Json : null
    }).eq('id', roomId)

    if (error) logger.error('supabase:database', 'Error saving room activity snapshot', error.message)
    return { data, error: error?.message }
}